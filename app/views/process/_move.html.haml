= form_with url: set_property_process_path do |f|
  = f.hidden_field :tab, value: params[:tab]
  = f.hidden_field :score, value: @info[:score]
  
  .columns
    .column.is-8
      .name_orig.mb-1
        %span.icon.in-text-small.mr-2
          %i.mi.mi-small(title="original filename") photo_filter
        = @fname

      - if @fname != @fname.to_romaji
        .name_romaji.mb-1
          %span.icon.in-text-small.mr-2
            %i.mi.mi-small(title="kakasi filename") translate
          = @fname.to_romaji #alt_readings:true, furigana_mode: true

      .file-type.mb-1
        %span.icon.in-text-small.mr-2
          %i.mi.mi-small(title="archive type") local_offer
        - if @info[:file_type] == 'doujin'
          = "#{@info[:doujin_dest_type]} #{@info[:file_type]}"
        - else
          = @info[:file_type]
          
      .other-settings.mb-1
        %span.icon.in-text-small.mr-2
          %i.mi.mi-small(title="other properties") settings
        
        .select(title="language")= f.select :language,
          options_for_select(Doujin::LANGUAGES, @info[:language]),
          {}, class: "input is-small vmiddle"
        
        .select(title="censored?")= f.select :censored,
          options_for_select({'uncensored' => false, 'censored' => true}, @info[:censored]),
          {}, class: "input is-small vmiddle"
        
        .select(title="colorized?")= f.select :colorized,
          options_for_select({'black & white' => false, 'colorized' => true}, @info[:colorized]),
          {}, class: "input is-small vmiddle"
        
        .select(title="reading direction")= f.select :reading_direction,
          options_for_select({'right to left' => 'r2l', 'left to right' => 'l2r'}, @info[:reading_direction]),
          {}, class: "input is-small vmiddle"

      .notes.mb-1
        %span.icon.in-text-small.mr-2
          %i.mi.mi-small(title="notes") comment
        = f.text_field :notes, value: @info[:notes], placeholder: 'notes',
          class: 'input is-small', style: 'width: 30.25rem'

      .scoring-stars.mb-1
        %span.icon.in-text-small.mr-2
          %i.mi.mi-small(title="quality score") favorite
        %span.scoring
          - (1..10).each do |i|
            %span.icon.is-medium.in-text.set-score{data: {score: i},
              class: (i <= @info[:score].to_i ? 'has-text-warning' : ''), title: i}
              %i.mi.mi-medium= i <= @info[:score].to_i ? :star_rate : :star_outline
              %span= i
          %span.icon.is-medium.in-text.clear-score{data: {score: 0}}
            %i.mi.mi-medium(title="clear") clear

      .subfolder.mb-1
        %span.icon.in-text-small.mr-2
          %i.mi.mi-small(title="destination subfolder") create_new_folder
        %span.select.vmiddle= f.select :sel_subfolder,
          options_for_select(@subfolders, @info[:subfolder]), {},
          class: "input is-small vmiddle", style: 'width: 15rem',
          onchange: %Q| $('#subfolder').val($(this).val() == '-custom name-' ? '' : $(this).val()) |
        = f.text_field :subfolder, value: @info[:subfolder], placeholder: 'destination subfolder',
          class: 'input is-small', style: 'width: 15rem'
        = link_to '#', class: 'button is-small', onclick: %Q|$('#subfolder').val(''); return false| do
          %span.icon
            %i.mi.mi-small(title="clear subfolder") clear

      .dest-filename.mb-1
        %span.icon.in-text-small.mr-2
          %i.mi.mi-small(title="destination filename") insert_drive_file
        = f.text_field :dest_filename, value: @info[:dest_filename], placeholder: 'destination filename',
          class: 'input is-small', style: 'width: 30.25rem',
          data: { orig_name: File.basename(@info[:relative_path]) }
        = link_to '#', class: 'button is-small',
          onclick: %Q|$('#dest_filename').val($('#dest_filename').data('orig-name')); return false| do
          %span.icon
            %i.mi.mi-small(title="restore initial filename") restore
      
      - if @suggestions
        .suggested-filenames.mb1.ml-6(title="suggested filenames" style="max-height: 10rem; overflow: auto;")
          %table.table.is-striped
            - @suggestions.each do |lbl|
              %tr
                %td= link_to lbl, '#', title: 'copy this suggestion',
                  onclick: %Q|jQuery('#dest_filename').val( jQuery(this).text().trim() + '.zip' ); return false|

      .final-path.mb-1
        %span.icon.in-text-small.mr-2
          %i.mi.mi-small(title="destination path") folder
        - if @collision_info
          %span.tag.is-danger= "ALREADY EXIST!"
        = Doujin.dest_path_by_process_params @info
      
      - if @collision_info
        .overwrite-confirm.mb-1
          %span.icon.in-text-small.mr-2
            %i.mi.mi-small(title="confirm overwrite") warning
          %span.has-text-danger
            = f.check_box :overwrite, {checked: @info[:overwrite], include_hidden: true}
            = label_tag :overwrite, "overwrite file in the collection"
    
      .actions.field.is-grouped.ml-6
        .field.has-addons
          %p.control
            = f.button class: 'button is-primary is-rounded' do
              %span.icon
                %i.mi.mi-small send
              %span update
          %p.control
            = link_to finalize_volume_process_path, method: :post,
              class: 'button is-success is-rounded' do
              %span.icon
                %i.mi.mi-small gavel
              %span finalize

    .column.has-text-centered
      - html_cover = capture do
        - base_dir = File.join(@dname, 'thumbs')
        
        - if @info[:landscape_cover] && @info[:landscape_cover_method] != :none
          %figure.image.is2by3= thumbnail_tag File.join(base_dir, '0000.webp'), title: "cropped cover"
          .control.has-icons-left
            - crop_methods = ProcessArchiveDecompressJob::CROP_METHODS.map{|m| ["crop #{m}", m] }
            .select.w100= f.select :cover_crop_method,
              options_for_select(crop_methods, @info[:landscape_cover_method].to_s), {},
              class: 'w100', onchange: %Q| this.form.submit() |
            .icon.is-small.is-left
              %i.mi(title="crop landscape cover") crop
          .control.is-hidden-mobile
            = link_to edit_cover_process_path(run: :image_editor, format: :json), remote: true, data: {spin_time: 15},
              class: "button run-progr is-small is-rounded", target: :_blank do
              %span.icon.is-small
                %i.mi add_photo_alternate
              %span duplicate & edit
          .control.is-hidden-mobile
            = link_to edit_cover_process_path(tab: params[:tab]),
              class: "button run-progr is-small is-rounded" do
              %span.icon.is-small
                %i.mi refresh
              %span refresh thumb
        - else
          - cover = @info[:images].first
          %figure.image.is2by3= thumbnail_tag File.join(base_dir, cover[:thumb_path]),
            title: "#{cover[:dst_path]} @ #{number_to_human_size cover[:size]}\nâ†ª#{cover[:src_path]}"
      
      - if @collision_info
        .columns
          .column.is-6(style="border-right: 1px solid transparent")
            .descr this file
            %span.tag.is-info.mb-1= @collision_info[:current]
            .this_cover= html_cover
          .column.is-6(style="border-left: 1px solid red")
            .descr
              - if dj_id = @collision_info[:doujin].try(:id)
                = link_to "collection ##{dj_id}", doujin_path(id: dj_id), target: :_blank
              - else
                collection
            %span.tag.is-info.mb-1= @collision_info[:collection]
            %figure.image.is2by3.coll_cover= image_tag doujin_path(id: @collision_info[:doujin].try(:id).to_i, format: :webp), title: "collision cover"
      - else
        = html_cover
